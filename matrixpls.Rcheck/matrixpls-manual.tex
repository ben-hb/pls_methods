\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `matrixpls'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Encoding]\AsIs{UTF-8}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Matrix-Based Partial Least Squares Estimation}
\item[Version]\AsIs{1.0.14}
\item[Date]\AsIs{2021-05-31}
\item[Maintainer]\AsIs{Mikko Rönkkö }\email{mikko.ronkko@jyu.fi}\AsIs{}
\item[Description]\AsIs{Partial Least Squares Path Modeling
algorithm and related algorithms. The algorithm implementations aim for
computational efficiency using matrix algebra and covariance data. The
package is designed toward Monte Carlo simulations and includes functions
to perform simple Monte Carlo simulations.}
\item[URL]\AsIs{}\url{https://github.com/mronkko/matrixpls}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/mronkko/matrixpls/issues}\AsIs{}
\item[ByteCompile]\AsIs{TRUE}
\item[Imports]\AsIs{assertive, lavaan, MASS, methods, psych}
\item[Suggests]\AsIs{simsem, RUnit, parallel, semPLS, boot, Matrix, ASGSCA, knitr,
R.rsp}
\item[License]\AsIs{GPL-3}
\item[LazyLoad]\AsIs{yes}
\item[LazyData]\AsIs{true}
\item[RoxygenNote]\AsIs{7.1.1}
\item[Collate]\AsIs{'convCheck.R' 'estimator.R' 'innerEstim.R' 'matrixpls.R'
'matrixpls.boot.R' 'matrixpls.crossvalidate.R'
'matrixpls.optim.R' 'matrixpls.plspm.R'
'matrixpls.postestimation.R' 'matrixpls.predict.R'
'matrixpls.sempls.R' 'matrixpls.sim.R' 'matrixpls.util.R'
'outerEstim.R' 'paramEstimator.R' 'reliabilityEstim.R'
'signChange.R' 'weightFun.R' 'weightSign.R'}
\item[VignetteBuilder]\AsIs{R.rsp}
\item[Depends]\AsIs{R (>= 2.10)}
\item[NeedsCompilation]\AsIs{no}
\item[Author]\AsIs{Mikko Rönkkö [aut, cre]}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{matrixpls-package}{Matrix-based Partial Least Squares estimation}{matrixpls.Rdash.package}
\aliasA{\_PACKAGE}{matrixpls-package}{.Rul.PACKAGE}
%
\begin{Description}\relax
\pkg{matrixpls} calculates composite variable models using partial least squares (PLS)
algorithm and related methods. In contrast to most other PLS software which implement
the raw data version of the algorithm, \pkg{matrixpls} works with data covariance matrices. The 
algorithms are designed to be computationally efficient, modular in programming, and well documented.
\pkg{matrixpls} integrates with \pkg{simsem} to enable Monte Carlo simulations with as little custom
programming as possible.
\end{Description}
%
\begin{Details}\relax
\pkg{matrixpls} calculates models where sets of indicator variables are combined as weighted composites. 
These composites are then used to estimate a statistical model describing the relationships between
the composites and composites and indicators. While a number of such methods exists, the partial
least squares (PLS) technique is perhaps the most widely used.

The \pkg{matrixpls} package implements a collection of PLS techniques as well as the more recent 
GSCA and PLSc techniques and older methods based on analysis with composite variables,
such as regression with
unit weighted composites or factor scores. The package provides a unified
framework that enables the comparison and analysis of these algorithms. In contrast to previous R
packages for PLS, such as plspm and \pkg{semPLS} and all currently
available commercial PLS software, which work with
raw data, \pkg{matrixpls} calculates the indicator weights and model estimates from data covariance 
matrices. Working with covariance data allows for reanalyzing covariance matrices that are sometimes
published as appendices of articles, is computationally more efficient, and lends itself more easily
for formal analysis than implementations based on raw data. 

\pkg{matrixpls} has modular design that is easily expanded and contains more calculation options
than the two other PLS packages for R. To allow validation of the algorithms by end users
and to help porting existing analysis files from the two other R packages to 
\pkg{matrixpls}, the package contains compatibility functions for both plspm and \pkg{semPLS}.

The design principles and functionality of the package is best explained by first explaining the main
function \code{matrixpls}. The function performs two tasks. It first calculates a set of indicator 
weights to form composites based on data covariance matrix and then estimates a statistical model
with the indicators and composites using the weights. The main function takes the following arguments:

\begin{alltt}
matrixpls(S, model, W.model = NULL, 
          weightFun = weightFun.pls, 
          parameterEstim = parameterEstim.separate,
          weightSign = NULL, ..., 
          validateInput = TRUE, standardize = TRUE)
\end{alltt}


The first five arguments of \code{\LinkA{matrixpls}{matrixpls}} are most relevant for understanding how the package
works. \code{S}, is the data covariance or correlation matrix. \code{model} defines the model
which is estimated in the second stage and \code{W.model} defines how the indicators are to be
aggregated as composites. If \code{W.model} is left undefined, it will be constructed based on
\code{model} following rules that are explained elsewhere in the documentation.
\code{weightFun} and 
\code{parameterEstim} are functions that 
implement the first and second task of the function respectively. All other arguments are passed 
down to these two functions, which in turn can pass arguments to other functions that they call.


Many of the commonly used arguments of \code{matrixpls} function are functions themselves. For 
example, executing a PLS analysis with Mode B outer estimation for all indicator blocks and centroid inner 
estimation could be specified as follows:

\begin{alltt}
matrixpls(S, model, 
          outerEstim = outerEstim.modeB,
          innerEstim = innerEstim.centroid)
\end{alltt}


The arguments \code{outerEstim} and \code{innerEstim} are not defined by the
\code{matrixpls} function, but are passed down to \code{weightFun.pls} which is used as the default
\code{weightFun}. \code{outerEstim.modeB} and \code{innerEstim.centroid} are themselves functions provided
by the \pkg{matrixpls} package, which perform the actual inner and outer estimation stages of the
PLS algorithm. Essentially, all parts of the estimation algorithm can be provided as arguments for
the main function. This allows for adjusting the inner workings of the algorithm in a way that is
currently not possible with any other PLS software.

It is also possible to define custom functions. For example, we could define a new Mode B outer
estimator that only produces positive weights by creating a custom function:

\begin{alltt}
myModeB <- function(...)\{
  abs(outerEstim.ModeB(...))
\}

matrixpls(S, model,
          outerEstim = myModeB,
          innerEstim = innerEstim.centroid)
\end{alltt}


Model can be specified in the lavaan format or the native matrixpls format.
The native model format is a list of three binary matrices, \code{inner}, \code{reflective},
and \code{formative} specifying the free parameters of a model: \code{inner} (\code{l x l}) specifies the 
regressions between composites, \code{reflective} (\code{k x l}) specifies the regressions of observed
data on composites, and \code{formative} (\code{l x k}) specifies the regressions of composites on the
observed data. Here \code{k} is the number of observed variables and \code{l} is the number of composites.

If the model is specified in lavaan format, the native
format model is derived from this model by assigning all regressions between latent
variables to \code{inner}, all factor loadings to \code{reflective}, and all regressions
of latent variables on observed variables to \code{formative}. Regressions between
observed variables and all free covariances are ignored. All parameters that are
specified in the model will be treated as free parameters.

The original papers about Partial Least Squares, as well as many of the current PLS
implementations, impose restrictions on the matrices \code{inner},
\code{reflective}, and \code{formative}: \code{inner} must be a lower triangular matrix,
\code{reflective} must have exactly one non-zero value on each row and must have at least
one non-zero value on each column, and \code{formative} must only contain zeros.
Some PLS implementations allow \code{formative} to contain non-zero values, but impose a
restriction that the sum of \code{reflective} and \code{t(formative)} must satisfy
the original restrictions of \code{reflective}. The only restrictions that matrixpls
imposes on \code{inner}, \code{reflective}, and \code{formative} is that these must be
binary matrices and that the diagonal of \code{inner} must be zeros.
\end{Details}
%
\begin{Author}\relax
\strong{Maintainer}: Mikko Rönkkö \email{mikko.ronkko@jyu.fi}

\end{Author}
%
\begin{References}\relax
Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling. \emph{Journal of Statistical Software}, 48(2), 1–36. Retrieved from http://www.jstatsoft.org/v48/i02

Lohmöller J.-B. (1989) \emph{Latent variable path modeling with partial least squares.} Heidelberg: Physica-Verlag.

Rönkkö, M., McIntosh, C. N., \& Antonakis, J. (2015). On the adoption of partial
least squares in psychological research: Caveat emptor. 
\emph{Personality and Individual Differences}, (87), 76–84. 
doi:\nobreakspace{}\Rhref{https://doi.org/10.1016/j.paid.2015.07.019}{10.1016\slash{}j.paid.2015.07.019}DOI:10.1016/j.paid.2015.07.019

Wold, H. (1982). Soft modeling - The Basic Design And Some Extensions. 
In K. G. Jöreskog \& S. Wold (Eds.),\emph{Systems under indirect observation:
causality, structure, prediction} (pp. 1–54). Amsterdam: North-Holland.
\end{References}
%
\begin{SeeAlso}\relax
Useful links:
\begin{itemize}

\item{} \url{https://github.com/mronkko/matrixpls}
\item{} Report bugs at \url{https://github.com/mronkko/matrixpls/issues}

\end{itemize}


\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{ave}{Average Variance Extracted indices for matrixpls results}{ave}
\keyword{post-estimation functions}{ave}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{ave} computes Average Variance Extracted 
indices for the model using the formula presented by Fornell and Larcker (1981).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ave(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list containing the Average Variance Extracted indices in the first position and the differences
between aves and largest squared correlations with other composites in the second position.
\end{Value}
%
\begin{References}\relax
Fornell, C., \& Larcker, D. F. (1981). Evaluating structural equation models with unobservable variables and measurement error. \emph{Journal of marketing research}, 18(1), 39–50.
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{cei}{Composite Equivalence Indices}{cei}
\keyword{post-estimation functions}{cei}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{cei} computes 
composite equivalence indices (CEI) for the \code{matrixpls} object. By
default, the composites are compared against unit-weighted composites.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cei(object, object2 = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{object2}] Another \code{matrixpls} object that \code{matrixpls} is
compared against.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Composite equivalence indices quantify if two sets of composites calculated
from the same data using different weight algorithms differ. Composites are 
matched by name and correlations for each pair are reported.
\end{Details}
%
\begin{Value}
Composite equivalence indices as a vector
\end{Value}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Load the Tenenhaus et al 2005 model and data from semPLS
library(semPLS)
data(ECSImobi)
data(mobi)

# Reflective and empty formative model
reflective<- ECSImobi$M
formative <- t(reflective)
formative[] <- 0

# Estimation using covariance matrix
model <- list(inner =  t(ECSImobi$D),
              reflective = reflective,
              formative = formative)


S <- cor(mobi)

matrixpls.ModeA <- matrixpls(S, model, innerEstim = innerEstim.centroid)
matrixpls.Fixed <- matrixpls(S, model, weightFun = weightFun.fixed)

cei(matrixpls.ModeA)
cei(matrixpls.ModeA, matrixpls.Fixed)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{convCheck}{Convergence checks}{convCheck}
\methaliasA{convCheck.absolute}{convCheck}{convCheck.absolute}
\methaliasA{convCheck.relative}{convCheck}{convCheck.relative}
\methaliasA{convCheck.square}{convCheck}{convCheck.square}
%
\begin{Description}\relax
The convergence check functions compare two weight matrices and returns the value of the
convergence criterion describing the difference between the two weight matrices.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
convCheck.relative(Wnew, Wold)

convCheck.square(Wnew, Wold)

convCheck.absolute(Wnew, Wold)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Wnew}] Current weight matrix

\item[\code{Wold}] Weight matrix from the previous iteration
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Scalar value of the convergence criterion
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{convCheck.relative}: maximum of relative differences between
weights from two iterations

\item{} \code{convCheck.square}: maximum of squared absolute 
differences between weights from two iterations.

\item{} \code{convCheck.absolute}: maximum of absolute differences
between weights from two iterations

\end{itemize}
\end{Section}
\inputencoding{utf8}
\HeaderA{cr}{Composite Reliability indices for matrixpls results}{cr}
\keyword{post-estimation functions}{cr}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{cr} computes Composite Reliability 
indices for the model using the formula presented by Fornell and Larcker (1981).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cr(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A named numeric vector containing the Composite Reliability indices.
\end{Value}
%
\begin{References}\relax
Fornell, C., \& Larcker, D. F. (1981). Evaluating structural equation models with unobservable variables and measurement error. \emph{Journal of marketing research}, 18(1), 39–50.

Aguirre-Urreta, M. I., Marakas, G. M., \& Ellis, M. E. (2013). Measurement of 
composite reliability in research using partial least squares: Some issues and
an alternative approach. 
\emph{The DATA BASE for Advances in Information Systems}, 44(4), 11–43. 
doi:\nobreakspace{}\Rhref{https://doi.org/10.1145/2544415.2544417}{10.1145\slash{}2544415.2544417}DOI:10.1145/2544415.2544417
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{effects.matrixpls}{Total, Direct, and Indirect Effects for matrixpls results}{effects.matrixpls}
\keyword{post-estimation functions}{effects.matrixpls}
%
\begin{Description}\relax
The \code{matrixpls} method for the standard generic function \code{effects} computes total, direct, 
and indirect effects for a matrixpls results according to the method described in Fox (1980).

Adapted from the \code{\LinkA{effects}{effects}} function of the \code{sem} package
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'matrixpls'
effects(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list with \code{Total}, \code{Direct}, and \code{Indirect} elements.
\end{Value}
%
\begin{References}\relax
Fox, J. (1980) Effect analysis in structural equation models: Extensions and simplified methods of computation. \emph{Sociological Methods and Research}
9, 3--28.
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{estimator}{Parameter estimation of a model matrix}{estimator}
\methaliasA{estimator.cfaLoadings}{estimator}{estimator.cfaLoadings}
\methaliasA{estimator.efaLoadings}{estimator}{estimator.efaLoadings}
\methaliasA{estimator.ols}{estimator}{estimator.ols}
\methaliasA{estimator.plscLoadings}{estimator}{estimator.plscLoadings}
\methaliasA{estimator.plsreg}{estimator}{estimator.plsreg}
\methaliasA{estimator.tsls}{estimator}{estimator.tsls}
%
\begin{Description}\relax
Estimates the parameters of a model matrix (\code{inner},
\code{reflective}, or \code{formative}).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
estimator.ols(S, modelMatrix, W, ..., C = NULL, IC = NULL, n = NULL)

estimator.tsls(S, modelMatrix, W, ..., C)

estimator.plscLoadings(S, modelMatrix, W, ...)

estimator.efaLoadings(S, modelMatrix, W, ..., fm = "minres")

estimator.cfaLoadings(S, modelMatrix, W, ...)

estimator.plsreg(S, modelMatrix, W, ..., C)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{modelMatrix}] A model matrix with dependent variables on rows, independent variables on colums, and
non-zero elements indicating relationships. Can be either \code{inner}, \code{reflective},
or \code{formative} matrix.

\item[\code{W}] Weight matrix, where the indicators are on colums and composites are on the rows.

\item[\code{...}] All other arguments are either ignored or passed through to third party estimation functions.

\item[\code{C}] Correlation matrix of the composites.

\item[\code{IC}] Correlation matrix of the composites and indicators.

\item[\code{n}] sample size, used for calculating standard errors.

\item[\code{fm}] factoring method for estimating the factor loadings. Passed through to \code{\LinkA{fa}{fa}}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Parameter estimation functions estimate the parameters of a model matrix (\code{inner},
\code{reflective}, or \code{formative}). These functions can be used as \code{parametersInner},
\code{parametersReflective}, and \code{parametersFormative} arguments for 
\code{\LinkA{parameterEstim.separate}{parameterEstim.separate}}.

When two-stage least squares regression is applied with \code{estimator.tsls}, all
exogenous variables are used as instrumental variables. There is currently no check of whether the
number of instrumental variables is sufficient for estimation.

\code{estimator.plscLoadings} estimates the loadings by scaling the weights \code{W} with the
correction factor \code{c} presented by Dijkstra (2011). This produces a MINRES estimator,
which constraints the loadings to be proportional to the weights.
The PLSc code is loosely based on code contributed by Wenjing Huang and developed with the guidance
by Theo Dijkstra.

\code{estimator.plscLoadings} estimates loadings with an unconstrained single factor model,
which requires at least three indicators per block. The loadings of 
single indicator factors are estimated as 1 and two indicator factors as estimated by the
square root of the indicator correlation.

Providing \code{C} or \code{IC} allows for using disattenuated or otherwise
adjusted correlation matrices. If not provided, these matrices are calculated using \code{S} and
\code{W}.

A part of the code for \code{\LinkA{estimator.plsreg}{estimator.plsreg}} is adopted from the plspm package, licensed
under GPL3.
\end{Details}
%
\begin{Value}
A matrix with estimated parameters or a list of two matrices containing estimates and
standard errors.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{estimator.ols}: parameter estimation with OLS regression. Can be applied to \code{inner}, \code{reflective},
or \code{formative} matrix.

\item{} \code{estimator.tsls}: parameter estimation with two-stage least squares regression. For \code{inner} matrix only.

\item{} \code{estimator.plscLoadings}: parameter estimation with Dijkstra's (2011) PLSc correction for loadings.  For \code{reflective} matrix only.

\item{} \code{estimator.efaLoadings}: parameter estimation with one indicator block at at time with exploratory
factor analysis. Minres estimation is implemented natively and all other
estimation techniques use the \code{\LinkA{fa}{fa}} function from the \code{psych} package. For \code{reflective} matrix only.

\item{} \code{estimator.cfaLoadings}: Estimates a maximum likelihood confirmatory factor analysis with \code{\LinkA{lavaan}{lavaan}}.  For \code{reflective} matrix only.

\item{} \code{estimator.plsreg}: parameter estimation with PLS regression. For \code{inner} matrix only.

\end{itemize}
\end{Section}
%
\begin{Author}\relax
Mikko Rönkkö, Wenjing Huang, Theo Dijkstra

Mikko Rönkkö, Gaston Sanchez, Laura Trinchera, Giorgio Russolillo
\end{Author}
%
\begin{References}\relax
Huang, W. (2013). PLSe: Efficient Estimators and Tests for Partial Least Squares (Doctoral dissertation). University of California, Los Angeles.

Dijkstra, T. K. (2011). Consistent Partial Least Squares estimators for linear and polynomial factor models. A report of a belated, serious and not even unsuccessful attempt. Comments are invited. Retrieved from http://www.rug.nl/staff/t.k.dijkstra/consistent-pls-estimators.pdf

Sanchez, G. (2013). \emph{PLS Path Modeling with R.} Retrieved from http://www.gastonsanchez.com/PLS Path Modeling with R.pdf
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
# Run the education example from the book

# Sanchez, G. (2013) PLS Path Modeling with R
# Trowchez Editions. Berkeley, 2013. 
# http://www.gastonsanchez.com/PLS Path Modeling with R.pdf

education <- read.csv("http://www.gastonsanchez.com/education.csv")

Support <- c(0, 0, 0, 0, 0, 0)
Advising <- c(0, 0, 0, 0, 0, 0)
Tutoring <- c(0, 0, 0, 0, 0, 0)
Value <- c(1, 1, 1, 0, 0, 0)
# Omit two paths (compared to the model in the book) to achieve 
# identification of the 2SLS analysis
Satisfaction <- c(0, 0, 1, 1, 0, 0)
Loyalty <- c(0, 0, 0, 0, 1, 0)

inner <- rbind(Support, Advising, Tutoring, Value, Satisfaction, Loyalty)


reflective <- diag(6)[c(rep(1,4),
                        rep(2,4),
                        rep(3,4),
                        rep(4,4),
                        rep(5,3),
                        rep(6,4)),]
formative <- matrix(0, 6, 23)

colnames(inner) <- colnames(reflective) <- rownames(formative) <- rownames(inner)
rownames(reflective) <- colnames(formative) <- colnames(education)[2:24]

education.model <- list(inner = inner,
              reflective = reflective,
              formative = formative)

# Reverse code two variables
education[,c("sup.under","loy.asha")] <- - education[,c("sup.under","loy.asha")]

S <- cor(education[,2:24])

# PLSc with OLS regression

education.out <- matrixpls(S,education.model,
                      disattenuate = TRUE,
                      parametersReflective = estimator.plscLoadings)

# PLSc with 2SLS regresssion

education.out2 <- matrixpls(S,education.model,
                      disattenuate = TRUE,
                      parametersReflective = estimator.plscLoadings,
                      parametersInner = estimator.tsls)


# Disattenuated regression with unit-weighted scales and exploratory factor analysis
# reliability estimates (with unconstrained MINRES estimator)

education.out3 <- matrixpls(S,education.model,
                       disattenuate = TRUE,
                       weightFun = weightFun.fixed,
                       parametersReflective = estimator.efaLoadings)

# Disattenuated GSCA with 2SLS regression after disattenuated based on 
# confirmatory factor analysis reliability estimates


education.out4 <- matrixpls(S,education.model,
                       disattenuate = TRUE,
                       innerEstim = innerEstim.gsca,
                       outerEstim = outerEstim.gsca,
                       parametersInner = estimator.tsls,
                       parametersReflective = estimator.cfaLoadings)


# Compare the results

cbind(PLSc = education.out, PLSc_2sls = education.out2, 
      DR = education.out3, GSCAc = education.out4)

# Compare the reliability estimates

cbind(PLSc = attr(education.out,"Q"), PLSc_2sls = attr(education.out2,"Q"), 
      DR = attr(education.out3,"Q"), GSCAc = attr(education.out4,"Q"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fitSummary}{Summary of model fit of PLS model}{fitSummary}
\keyword{post-estimation functions}{fitSummary}
%
\begin{Description}\relax
\code{fitSummary} computes a list of statistics
that are commonly used to access the overall fit of the PLS model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fitSummary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list containing a selection of fit indices.
\end{Value}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{fitted.matrixpls}{Model implied covariance matrix based on matrixpls results}{fitted.matrixpls}
\keyword{post-estimation functions}{fitted.matrixpls}
%
\begin{Description}\relax
The \code{matrixpls} method for generic function \code{fitted} computes the model implied
covariance matrix by combining  \code{inner}, \code{reflective}, and \code{formative} as a 
simultaneous equations system. The error terms are constrained to be uncorrelated and 
covariances between exogenous variables are fixed at their sample values. Defining a
composite as dependent variable in both inner and formative creates an impossible model
and results in an error.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'matrixpls'
fitted(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix containing the model implied covariances.
\end{Value}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{gof}{Goodness of Fit indices for matrixpls results}{gof}
\keyword{post-estimation functions}{gof}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{gof} computes the Goodness of Fit index for matrixpls results.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
gof(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The Goodness of Fit index.
\end{Value}
%
\begin{References}\relax
Henseler, J., \& Sarstedt, M. (2013). Goodness-of-fit indices for partial least
squares path modeling. \emph{Computational Statistics}, 28(2), 565–580. 
doi:\nobreakspace{}\Rhref{https://doi.org/10.1007/s00180-012-0317-1}{10.1007\slash{}s00180\-012\-0317\-1}
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{GSCA}{Generalized structured component analysis (GSCA) weights}{GSCA}
%
\begin{Description}\relax
When used with \code{\LinkA{weightFun.pls}{weightFun.pls}}, \code{\LinkA{innerEstim.gsca}{innerEstim.gsca}} and 
\code{\LinkA{outerEstim.gsca}{outerEstim.gsca}} implement the generalized structured component analysis
indicator weighting system. Using \code{\LinkA{weightFun.optim}{weightFun.optim}} with the
\code{\LinkA{optimCrit.gsca}{optimCrit.gsca}} optimization criterion provides an alternative
approach to calculate GSCA weights by direct numerical minimization of the
GSCA criterion function.
\end{Description}
%
\begin{Details}\relax
The two step GSCA weight algorithm is designed to minimize.

\code{SS(ZV-ZWA)}

The parameter matrix \code{A} contains all model parameters including
\code{inner}, reflective \code{inner}, and \code{formative}. The weight
matrices \code{V} and \code{W}, which can contain duplicate elements,
contain the indicator weights.

The first step of GSCA estimation method is calculation of regressions
coefficients \code{A} given weights \code{W} and \code{V}. The function
\code{\LinkA{innerEstim.gsca}{innerEstim.gsca}} update the part of \code{A} corresponding to 
regressions between the composites, corresponding to \code{E} matrix in 
matrixpls. The regressions between composites and indicators are estimated
in \code{\LinkA{outerEstim.gsca}{outerEstim.gsca}}.

This algorithm for estimating the relationships between the composites
is therefore identical to the PLS path weighting scheme with
the exception that correlations are not used for inverse relationships and
there is no falling back to identity scheme for composites that are not
connected to other composites
The second step of GSCA is calculating a new set of weights conditional on
the regression coeffcients \code{A} to minimize the sum of error terms in
the regressions. This step is implemented in \code{\LinkA{outerEstim.gsca}{outerEstim.gsca}} after
updating the regressions between indicators and composites.
The implementation of GSCA in \pkg{matrixpls} differs from the Hwang \& Takane (2004)
version in that during the first step, only regressions between composites are
estimated. The regressions between composites and indicators are estimated by
the second stage 
the indicators and composites. Since these covariances need to be calculated in the second step, it is more
efficient to not calculate them during the first step.

A part of the code for \code{\LinkA{outerEstim.gsca}{outerEstim.gsca}} is adopted from the \pkg{ASGCA} package, licensed
under GPL3.
\end{Details}
%
\begin{Author}\relax
Mikko Rönkkö, Hela Romdhani, Stepan Grinek, Heungsun Hwang, Aurelie Labbe.
\end{Author}
%
\begin{References}\relax
Hwang, H., \& Takane, Y. (2004). Generalized structured component analysis. 
Psychometrika, 69(1), 81–99. doi:\nobreakspace{}\Rhref{https://doi.org/10.1007/BF02295841}{10.1007\slash{}BF02295841}

Hela Romdhani, Stepan Grinek, Heungsun Hwang and Aurelie Labbe. (2014). 
ASGSCA: Association Studies for multiple SNPs and multiple traits using
Generalized Structured Equation Models. R package version 1.4.0.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
if(!require(ASGSCA)){
    print("This example requires the ASGSCA package from Bioconductor")
} else{
# Run the example from ASGSCA package using GSCA estimation

data(GenPhen)
W0 <- matrix(c(rep(1,2),rep(0,8),rep(1,2),rep(0,8),rep(1,3),rep(0,7),rep(1,2)),
             nrow=8,ncol=4)
B0 <- matrix(c(rep(0,8),rep(1,2),rep(0,3),1,rep(0,2)),nrow=4,ncol=4)

# Set seed becayse ASGSCA uses random numbers as starting values 
set.seed(1)

GSCA.res <-GSCA(GenPhen,W0, B0,estim=TRUE,path.test=FALSE, 
                 latent.names=c("Gene1","Gene2",
                                "Clinical pathway 1",
                                "Clinical pathway 2"))

# Setup matrixpls to estimate the same model. Note that ASGSCA places dependent
# variables on columns but matrixpls uses rows for dependent variables

inner <- t(B0)
formative <- t(W0)
reflective <- matrix(0,8,4)

colnames(formative) <- rownames(reflective) <- names(GenPhen)

colnames(inner) <- rownames(inner) <- 
  rownames(formative) <- colnames(reflective) <-
  c("Gene1","Gene2","Clinical pathway 1","Clinical pathway 2")

model <- list(inner = inner, 
              reflective = reflective,
              formative = formative)

# Estimate using alternating least squares

matrixpls.res1 <- matrixpls(cov(GenPhen),  model,
                            outerEstim = outerEstim.gsca,
                            innerEstim = innerEstim.gsca)

# Estimate using direct minimization of the estimation criterion
# Set the convergence criterion to be slightly stricter than normally
# to get indentical results

matrixpls.res2 <- matrixpls(cov(GenPhen),  model,
                            weightFun = weightFun.optim,
                            optimCrit = optimCrit.gsca,
                            control = list(reltol = 1e-12))

# Compare the weights

do.call(cbind,lapply(list(ASGSCA =GSCA.res[["Weight"]],
                          matrixpls_als = t(attr(matrixpls.res1,"W")),
                          matrixpls_optim =t(attr(matrixpls.res2,"W"))),
                     function(W) W[W!=0]))


# Check the criterion function values

optimCrit.gsca(matrixpls.res1)
optimCrit.gsca(matrixpls.res2)

}
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{htmt}{Heterotrait-monotrait ratio}{htmt}
\keyword{post-estimation functions}{htmt}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{htmt} computes Heterotrait-monotrait ratio 
for the model using the formula presented by Henseler et al (2014).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
htmt(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Heterotrait-monotrait ratio as a scalar
\end{Value}
%
\begin{References}\relax
Henseler, J., Ringle, C. M., \& Sarstedt, M. (2015). A new criterion for assessing discriminant validity in variance-based structural equation modeling. \emph{Journal of the Academy of Marketing Science}, 43(1), 115–135.
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{innerEstim}{PLS inner estimation}{innerEstim}
\methaliasA{innerEstim.centroid}{innerEstim}{innerEstim.centroid}
\methaliasA{innerEstim.factor}{innerEstim}{innerEstim.factor}
\methaliasA{innerEstim.gsca}{innerEstim}{innerEstim.gsca}
\methaliasA{innerEstim.identity}{innerEstim}{innerEstim.identity}
\methaliasA{innerEstim.path}{innerEstim}{innerEstim.path}
%
\begin{Description}\relax
Calculates a set of inner weights.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
innerEstim.centroid(S, W, inner.mod, ignoreInnerModel = FALSE, ...)

innerEstim.path(S, W, inner.mod, ...)

innerEstim.factor(S, W, inner.mod, ignoreInnerModel = FALSE, ...)

innerEstim.identity(S, W, inner.mod, ...)

innerEstim.gsca(S, W, inner.mod, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{W}] Weight matrix, where the indicators are on colums and composites are on the rows.

\item[\code{inner.mod}] A square matrix specifying the relationships of the composites in the model.

\item[\code{ignoreInnerModel}] Should the inner model be ignored and all correlations be used.

\item[\code{...}] Other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In the centroid scheme, inner weights are set to the signs (1 or -1) of correlations between
composites that are connected in the model specified in \code{inner.mod} and zero otherwise.

In the path scheme, inner weights are based on regression estimates of the relationships between
composites that are connected in the model specified in \code{inner.mod}, and correlations for
the inverse relationships. If a relationship is reciprocal, regression is used for both directions.

In the factor scheme, inner weights are set to the correlations between
composites that are connected in the model specified in \code{inner.mod} and zero otherwise.

In the identity scheme identity matrix is used as the inner weight matrix \code{E}.

Centroid, inner, and path schemes fall back to to identity scheme for composites 
that are not connected to any other composites.

For information about GSCA weights, see \LinkA{GSCA}{GSCA}.
\end{Details}
%
\begin{Value}
A matrix of unscaled inner weights \code{E} with the same dimensions as \code{inner.mod}.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{innerEstim.centroid}: inner estimation with centroid scheme.

\item{} \code{innerEstim.path}: inner estimation with path scheme.

\item{} \code{innerEstim.factor}: inner estimation with factor scheme.

\item{} \code{innerEstim.identity}: inner estimation with identity scheme.

\item{} \code{innerEstim.gsca}: inner estimation with generalized structured component analysis.

\end{itemize}
\end{Section}
%
\begin{References}\relax
Lohmöller J.-B. (1989) \emph{Latent variable path modeling with partial least squares.} Heidelberg: Physica-Verlag.
\end{References}
\inputencoding{utf8}
\HeaderA{loadings}{Factor loadings matrix from matrixpls results}{loadings}
\keyword{post-estimation functions}{loadings}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{loadings} computes standardized factor loading matrix
from the model results.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
loadings(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of estimated factor loadings.
\end{Value}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{matrixpls}{Partial Least Squares and other composite variable models.}{matrixpls}
%
\begin{Description}\relax
Estimates a weight matrix using Partial Least Squares or a related algorithm and then
uses the weights to estimate the parameters of a statistical model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matrixpls(
  S,
  model,
  W.model = NULL,
  weightFun = weightFun.pls,
  parameterEstim = parameterEstim.separate,
  weightSign = NULL,
  ...,
  validateInput = TRUE,
  standardize = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{W.model}] An optional numeric matrix representing the weight pattern and starting weights
(i.e. the how the indicators are combined to form the composite variables). If this argument is not specified,
the weight patter is defined based on the relationships in the \code{reflective} and  \code{formative}
elements of \code{model}.

\item[\code{weightFun}] A function for calculating indicator weights using the data covariance matrix
\code{S}, a model specification \code{model}, and a weight pattern \code{W.model}. Returns
a weight matrix \code{W}. The default is \code{\LinkA{weightFun.pls}{weightFun.pls}}

\item[\code{parameterEstim}] A function for estimating the model parameters using
the data covariance matrix \code{S}, model specification \code{model}, 
and weight matrix \code{W}. Returns a named vector of parameter estimates.
The default is \code{\LinkA{parameterEstim.separate}{parameterEstim.separate}}

\item[\code{weightSign}] A function for resolving weight sign ambiguity based on the data covariance matrix
\code{S} and a weight matrix \code{W}.  Returns
a weight matrix \code{W}. See \code{\LinkA{weightSign}{weightSign}}
for details.

\item[\code{...}] All other arguments are passed through to \code{weightFun} and \code{parameterEstim}.

\item[\code{validateInput}] If \code{TRUE}, the arguments are validated.

\item[\code{standardize}] If \code{TRUE}, \code{S} is converted to a correlation matrix before analysis.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{matrixpls} is the main function of the matrixpls package. This function
parses a model object and then uses the results to call \code{weightFun} to
to calculate indicator weight. After this the \code{parameterEstim} function is
applied to the indicator weights, the data covariance matrix,
and the model object and the resulting parameter estimates are returned.

Model can be specified in the lavaan format or the native matrixpls format.
The native model format is a list of three binary matrices, \code{inner}, \code{reflective},
and \code{formative} specifying the free parameters of a model: \code{inner} (\code{l x l}) specifies the 
regressions between composites, \code{reflective} (\code{k x l}) specifies the regressions of observed
data on composites, and \code{formative} (\code{l x k}) specifies the regressions of composites on the
observed data. Here \code{k} is the number of observed variables and \code{l} is the number of composites.

If the model is specified in lavaan format, the native
format model is derived from this model by assigning all regressions between latent
variables to \code{inner}, all factor loadings to \code{reflective}, and all regressions
of latent variables on observed variables to \code{formative}. Regressions between
observed variables and all free covariances are ignored. All parameters that are
specified in the model will be treated as free parameters.

The original papers about Partial Least Squares, as well as many of the current PLS
implementations, impose restrictions on the matrices \code{inner},
\code{reflective}, and \code{formative}: \code{inner} must be a lower triangular matrix,
\code{reflective} must have exactly one non-zero value on each row and must have at least
one non-zero value on each column, and \code{formative} must only contain zeros.
Some PLS implementations allow \code{formative} to contain non-zero values, but impose a
restriction that the sum of \code{reflective} and \code{t(formative)} must satisfy
the original restrictions of \code{reflective}. The only restrictions that matrixpls
imposes on \code{inner}, \code{reflective}, and \code{formative} is that these must be
binary matrices and that the diagonal of \code{inner} must be zeros.

The argument \code{W.model} is a (\code{l x k}) matrix that indicates
how the indicators are combined to form the composites. The original papers about
Partial Least Squares as well as all current PLS implementations define this as
\code{t(reflective) | formative}, which means that the weight patter must match the
model specified in \code{reflective} and \code{formative}. Matrixpls does not
require that \code{W.model} needs to match \code{reflective} and \code{formative}, but
accepts any numeric matrix. If this argument is not specified, all elements of \code{W.model} that
correspond to non-zero elements in the \code{reflective} or \code{formative} formative
matrices receive the value 1.
\end{Details}
%
\begin{Value}
A named numeric vector of class \code{matrixpls} containing the parameter estimates followed by weights.

\code{matrixpls} returns the following as attributes:

\begin{ldescription}
\item[\code{W}] the weight matrix.
\item[\code{model}] the model specification in native format.
\item[\code{call}] the function call.

\end{ldescription}
Additionally, all attributes returned by functions called by matrixpls are returned.
This can include:
\begin{ldescription}
\item[\code{S}] the sample covariance matrix.
\item[\code{E}] inner weight matrix.
\item[\code{iterations}] the number of iterations used by the weight algorithm.
\item[\code{converged}] \code{TRUE} if the weight algorithm converged and \code{FALSE} otherwise.
\item[\code{history}] weight optimization history as a matrix.
\item[\code{C}] the composite correlation matrix (after disattenuation, if requested).
\item[\code{IC}] the indicator-composite covariance matrix (after disattenuation, if requested).
\item[\code{inner}] the \code{inner} model matrix with estimated parameters.
\item[\code{reflective}] the \code{reflective} model matrix with estimated parameters.
\item[\code{formative}] the \code{formative} model matrix with estimated parameters.
\item[\code{Q}] the reliability estimates used in disattenuation.
\item[\code{c}] the PLSc loading estimate correction factors.
\end{ldescription}
\end{Value}
%
\begin{References}\relax
Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling. \emph{Journal of Statistical Software}, 48(2), 1–36. Retrieved from http://www.jstatsoft.org/v48/i02

Wold, H. (1982). Soft modeling - The Basic Design And Some Extensions. In K. G. Jöreskog \& S. Wold (Eds.),\emph{Systems under indirect observation: causality, structure, prediction} (pp. 1–54). Amsterdam: North-Holland.
\end{References}
%
\begin{SeeAlso}\relax
Weight algorithms: \code{\LinkA{weightFun.pls}{weightFun.pls}}; \code{\LinkA{weightFun.fixed}{weightFun.fixed}}; \code{\LinkA{weightFun.optim}{weightFun.optim}}; \code{\LinkA{weightFun.principal}{weightFun.principal}}; \code{\LinkA{weightFun.factor}{weightFun.factor}}

Weight sign corrections:\code{\LinkA{weightSign.Wold1985}{weightSign.Wold1985}}; \code{\LinkA{weightSign.dominantIndicator}{weightSign.dominantIndicator}}

Parameter estimators: \code{\LinkA{parameterEstim.separate}{parameterEstim.separate}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{matrixpls-common}{Commonly used arguments}{matrixpls.Rdash.common}
%
\begin{Description}\relax
The following describes commonly used arguments in the \pkg{matrixpls} package.
\end{Description}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{W}] Weight matrix, where the indicators are on colums and composites are on the rows.

\item[\code{C}] Correlation matrix of the composites.

\item[\code{IC}] Correlation matrix of the composites and indicators.

\item[\code{E}] Inner weight matrix. A square matrix of inner estimates between the composites.

\item[\code{W.model}] A matrix specifying the weight relationships and their starting values.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{matrixpls-functions}{All estimation function types}{matrixpls.Rdash.functions}
%
\begin{Description}\relax
The following describes all estimation function types used in \pkg{matrixpls} package.
\end{Description}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{weightFun}] A function for calculating indicator weights using the data covariance matrix
\code{S}, a model specification \code{model}, and a weight pattern \code{W.model}. Returns
a weight matrix \code{W}. The default is \code{\LinkA{weightFun.pls}{weightFun.pls}}

\item[\code{parameterEstim}] A function for estimating the model parameters using
the data covariance matrix \code{S}, model specification \code{model}, 
and weight matrix \code{W}. Returns a named vector of parameter estimates.
The default is \code{\LinkA{parameterEstim.separate}{parameterEstim.separate}}

\item[\code{estimator}] A function for estimating the parameters of one model matrix using
the data covariance matrix \code{S}, a model matrix \code{modelMatrix}, and a weight matrix
\code{W}. Disattenuated composite correlation matrix \code{C} and indicator composite 
covariance matrix \code{IC} are optional. Returns matrix of parameter estimates.
The default is \code{\LinkA{estimator.ols}{estimator.ols}}

\item[\code{weightSign}] A function for resolving weight sign ambiguity based on the data covariance matrix
\code{S} and a weight matrix \code{W}.  Returns
a weight matrix \code{W}. See \code{\LinkA{weightSign}{weightSign}}
for details.

\item[\code{outerEstim}] A function for calculating outer weights using the data covariance matrix
\code{S}, a weight matrix \code{W}, an inner weight matrix \code{E},
and a weight pattern \code{W.model}. Returns
a weight matrix \code{W}. See \code{\LinkA{outerEstim}{outerEstim}}.

\item[\code{innerEstim}] A function for calculating inner weights using  the data covariance matrix
\code{S}, a weight matrix \code{W}, and an inner model matrix \code{inner.mod}. Returns
an inner weight matrix \code{E}. The default is \code{\LinkA{innerEstim.path}{innerEstim.path}}.

\item[\code{convCheck}] A function that takes the old \code{Wold} and new weight \code{Wold} matrices and
returns a scalar that is compared against \code{tol} to check for convergence. The default
is \code{\LinkA{convCheck.absolute}{convCheck.absolute}}.

\item[\code{optimCrit}] A function for calculating value for an optimization criterion based on a
\code{matrixpls} result object. Returns a scalar. The default is \code{\LinkA{optimCrit.maximizeInnerR2}{optimCrit.maximizeInnerR2}}.

\item[\code{reliabilities}] A function for calculating reliability estimates based on the 
data covariance matrix \code{S}, factor loading matrix \code{loadings}, and a weight matrix \code{W}.
Returns a vector of reliability estimates. The default is
\code{\LinkA{reliabilityEstim.weightLoadingProduct}{reliabilityEstim.weightLoadingProduct}}
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{matrixpls.crossvalidate}{Cross-validation of predictions from matrixpls results}{matrixpls.crossvalidate}
%
\begin{Description}\relax
\code{matrixpls.crossvalidate} Calculates cross-validation predictions using \code{matrixpls}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matrixpls.crossvalidate(
  data,
  model,
  ...,
  predictFun = stats::predict,
  nGroup = 4,
  blindfold = FALSE,
  imputationFun = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Matrix or data frame containing the raw data.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{...}] All other arguments are passed through to \code{\LinkA{matrixpls}{matrixpls}} and \code{predictFun}.

\item[\code{predictFun}] The function used to calculate the predictions.

\item[\code{nGroup}] The number of groups to divide the data into.

\item[\code{blindfold}] Whether blindfolding should be used instead of holdout sample cross-validation.

\item[\code{imputationFun}] The function used to impute missing data before blindfold prediction. 
If \code{NULL}, simple mean substitution is used.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In cross-validation, some elements of the data matrix are set to missing and then
predicted based on the remaining observations. The process is repeated until all elements
of the data have been predicted. 

Cross-validation is typically applied by dividing the data into two groups, the training
sample and the validation sample. The prediction model is calculated based on the 
training sample and used to calculate predictions for the validation sample.

In blindfolding, the data are not omitted case wise, but elements of the data are omitted
diagonally. After this, imputation is applied to missing data and the prediction model
is calibrated with the dataset containing also the imputations. The imputed values are then 
predicted with the model.
\end{Details}
%
\begin{Value}
A matrix containing predictions calculated with cross-validation.
\end{Value}
%
\begin{References}\relax
Chin, W. W. (2010). How to write up and report PLS analyses. In V. Esposito Vinzi, W. W. Chin, J.
Henseler, \& H. Wang (Eds.), Handbook of partial least squares (pp. 655–690). Berlin Heidelberg: Springer.

Chin, W. W. (1998). The partial least squares approach to structural equation modeling. 
In G. A. Marcoulides (Ed.), Modern methods for business research (pp. 295–336). 
Mahwah, NJ: Lawrence Erlbaum Associates Publishers.
\end{References}
\inputencoding{utf8}
\HeaderA{matrixpls.plspm}{A plspm compatibility wrapper for matrixpls}{matrixpls.plspm}
%
\begin{Description}\relax
\code{matrixpls.plspm} mimics \code{plspm} function of the \code{plspm} package.
The arguments and their default values and the output of the function are identical with \code{plspm} function,
but internally the function uses matrixpls estimation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matrixpls.plspm(
  Data,
  path_matrix,
  blocks,
  modes = NULL,
  scheme = "centroid",
  scaled = TRUE,
  tol = 1e-06,
  maxiter = 100,
  boot.val = FALSE,
  br = NULL,
  dataset = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Data}] matrix or data frame containing the manifest variables.

\item[\code{path\_matrix}] A square (lower triangular) boolean matrix representing 
the inner model (i.e. the path relationships between latent variables).

\item[\code{blocks}] list of vectors with column indices or column names
from \code{Data} indicating the sets of manifest variables forming 
each block (i.e. which manifest variables correspond to each block).

\item[\code{modes}] character vector indicating the type of measurement for each
block. Possible values are: \code{"A", "B"}. 
The length of \code{modes} must be equal to the length of \code{blocks}.

\item[\code{scheme}] string indicating the type of inner weighting
scheme. Possible values are \code{"centroid"}, \code{"factorial"}, or
\code{"path"}.

\item[\code{scaled}] whether manifest variables should be standardized. 
When (\code{TRUE}, data is 
scaled to standardized values (mean=0 and variance=1). 
The variance is calculated dividing by \code{N} instead of \code{N-1}).

\item[\code{tol}] decimal value indicating the tolerance criterion for the
iterations (\code{tol=0.000001}). Can be specified between 0 and 0.001.

\item[\code{maxiter}] integer indicating the maximum number of iterations
(\code{maxiter=100} by default). The minimum value of \code{maxiter} is 100.

\item[\code{boot.val}] whether bootstrap validation should be performed. 
(\code{FALSE} by default).

\item[\code{br}] number bootstrap resamples. Used only
when \code{boot.val=TRUE}. When \code{boot.val=TRUE}, the default number of 
re-samples is 100.

\item[\code{dataset}] whether the data matrix used in the computations should be
retrieved (\code{TRUE} by default).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The function \code{matrixpls.plspm} calculates indicator weights and estimates a model
identically to the  \code{plspm} function. In contrast to the \code{\LinkA{matrixpls}{matrixpls}} function
that provides only weights and parameter estimates, this function also reports multiple post-estimation
statistics. Because of this \code{matrixpls.plspm} is substantially less efficient than the \code{\LinkA{matrixpls}{matrixpls}}
function.

The argument \code{path\_matrix} is a matrix of zeros and ones that indicates
the structural relationships between composites. This must be a lower
triangular matrix. \code{path\_matrix} will contain a 1 when column \code{j}
affects row \code{i}, 0 otherwise. \\{}
\end{Details}
%
\begin{Value}
An object of class \code{"plspm"}.

\begin{ldescription}
\item[\code{outer\_model}] Results of the outer model. Includes:
outer weights, standardized loadings, communalities, and redundancies

\item[\code{inner\_model}] Results of the inner (structural) model. 
Includes: path coeffs and R-squared for each endogenous latent variable

\item[\code{scores}] Matrix of latent variables used to estimate the inner
model. If \code{scaled=FALSE} then \code{scores} are latent variables
calculated with the original data (non-standardized).

\item[\code{path\_coefs}] Matrix of path coefficients 
(this matrix has a similar form as \code{path\_matrix})

\item[\code{crossloadings}] Correlations between the latent variables 
and the manifest variables (also called crossloadings)

\item[\code{inner\_summary}] Summarized results of the inner model. 
Includes: type of LV, type of measurement, number of indicators, R-squared,
average communality, average redundancy, and average variance
extracted

\item[\code{effects}] Path effects of the structural relationships. 
Includes: direct, indirect, and total effects

\item[\code{unidim}] Results for checking the unidimensionality of blocks
(These results are only meaningful for reflective blocks)

\item[\code{gof}] Goodness-of-Fit index

\item[\code{data}] Data matrix containing the manifest variables used in the
model. Only available when \code{dataset=TRUE}

\item[\code{boot}] List of bootstrapping results; only available 
when argument \code{boot.val=TRUE}
\end{ldescription}
\end{Value}
%
\begin{References}\relax
Sanchez, G. (2013). \emph{PLS Path Modeling with R.} Retrieved from http://www.gastonsanchez.com/PLS Path Modeling with R.pdf
\#'
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
cores <- getOption("mc.cores")
options(mc.cores=2)

# Run the example from plspm package

# load dataset satisfaction
data(satisfaction)
# inner model matrix
IMAG = c(0,0,0,0,0,0)
EXPE = c(1,0,0,0,0,0)
QUAL = c(0,1,0,0,0,0)
VAL = c(0,1,1,0,0,0)
SAT = c(1,1,1,1,0,0)
LOY = c(1,0,0,0,1,0)
sat_inner = rbind(IMAG, EXPE, QUAL, VAL, SAT, LOY)
# outer model list
sat_outer = list(1:5, 6:10, 11:15, 16:19, 20:23, 24:27)
# vector of modes (reflective indicators)
sat_mod = rep("A", 6)

# apply matrixpls
matrixpls.res <- matrixpls.plspm(satisfaction, sat_inner, sat_outer, sat_mod,
                                 scaled=FALSE, boot.val=FALSE)

print(summary(matrixpls.res))

options(mc.cores=cores)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{matrixpls.sempls}{A semPLS compatibility wrapper for matrixpls}{matrixpls.sempls}
%
\begin{Description}\relax
\code{matrixpls.sempls} mimics \code{\LinkA{sempls}{sempls}} function of the \code{semPLS} package.
The arguments and their default values and the output of the function are identical with \code{\LinkA{sempls}{sempls}} function,
but internally the function uses matrixpls estimation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matrixpls.sempls(
  model,
  data,
  maxit = 20,
  tol = 1e-07,
  scaled = TRUE,
  sum1 = FALSE,
  wscheme = "centroid",
  pairwise = FALSE,
  method = c("pearson", "kendall", "spearman"),
  convCrit = c("relative", "square"),
  verbose = TRUE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] An object inheriting from class \code{plsm} as returned from \code{\LinkA{plsm}{plsm}}
or \code{\LinkA{read.splsm}{read.splsm}}.

\item[\code{data}] 
A \code{data.frame} containing the observed variables
(MVs). The storage mode for all the MVs included in the model must
be \code{numeric}.


\item[\code{maxit}] 
A \code{numeric} value, which determines the maximum number of
iterations performed by the PLS algorithm. The default is \eqn{20}{}
iterations.


\item[\code{tol}] 
A \code{numeric} value, specifying the tolerance for the maximum relative
differences in the outer weights. The default value is
\eqn{10^{-7}}{}.


\item[\code{scaled}] 
A \code{logical} value indicating, whether the observed
data shall be scaled to zero mean and unit variance. The default is
\code{TRUE}.


\item[\code{sum1}] 
A \code{logical} value indicating, whether the outer
weights foreach latent variable (LV) shall be standardized to sum up
to one. The default is \code{FALSE}. Since the factor scores are
scaled in each step of the PLS algorithm, changing this value to
\code{TRUE} does not affect the results.


\item[\code{wscheme}] 
A \code{character} naming the weighting scheme to
use. Possible values are:
\begin{itemize}

\item{} \code{"A"} or \code{"centroid"} for the centroid scheme, the default,
\item{} \code{"B"} or \code{"factorial"}for the factorial scheme and
\item{} \code{"C"}, \code{"pw"} or \code{"pathWeighting"} for the path weighting scheme.

\end{itemize}



\item[\code{pairwise}] A \code{logical} value indicating, whether
correlations shall be calculated pairwise. If the observed data
does not contain missing values, the results are not affected.
The default is \code{FALSE}. For more details the R help,
\code{?cor}, can be consulted.

\item[\code{method}] A \code{character} naming the method to calculate
the correlations. Possible values are:
\begin{itemize}

\item{} \code{"pearson"} , the default,
\item{} \code{"kendall"},
\item{} \code{"spearman"}.

\end{itemize}

For more details on the method, the R help, \code{?cor}, can be
consulted. Note, that despite of the \code{method} argument, pearson
correlations are always used for the inner approximation (step 2).


\item[\code{convCrit}] 
The convergence criteria to use:
\begin{itemize}

\item{} \code{"relative"}, the default,
\item{} \code{"square"}.

\end{itemize}



\item[\code{verbose}] 
Logical: If \code{FALSE} no status messages are printed.


\item[\code{...}] Other arguments are ignored
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An object of class \code{\LinkA{sempls}{sempls}}.
\end{Value}
%
\begin{References}\relax
Monecke, A., \& Leisch, F. (2012). semPLS: Structural Equation Modeling Using Partial Least Squares. \emph{Journal of Statistical Software}, 48(3), 1–32.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{sempls}{sempls}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
if(!require(semPLS)){
    print("This example requires the semPLS package")
} else{
data(ECSImobi)

ecsi.sempls <- sempls(model=ECSImobi, data=mobi, wscheme="pathWeighting")
ecsi <- matrixpls.sempls(model=ECSImobi, data=mobi, wscheme="pathWeighting")

# If RUnit is installed check that the results are identical

if(require(RUnit)){
  checkEquals(ecsi.sempls,ecsi, check.attributes = FALSE)
}

ecsi

## create plots
densityplot(ecsi)
densityplot(ecsi, use="prediction")
densityplot(ecsi, use="residuals")

## Values of 'sempls' objects
names(ecsi)
ecsi$outer_weights
ecsi$outer_loadings
ecsi$path_coefficients
ecsi$total_effects


### using convenience methods to sempls results
## path coefficients
pathCoeff(ecsi)

## total effects
totalEffects(ecsi)

## get loadings and check for discriminant validity
(l <- plsLoadings(ecsi))
# outer loadings
print(l, type="outer", digits=2)
# outer loadings greater than 0.5
print(l,type="outer", cutoff=0.5, digits=2)
# cross loadings greater than 0.5
print(l, type="cross", cutoff=0.5, digits=2)


### R-squared
rSquared(ecsi)

}
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{matrixpls.sim}{Monte Carlo simulations with matrixpls}{matrixpls.sim}
%
\begin{Description}\relax
Performs Monte Carlo simulations of \code{\LinkA{matrixpls}{matrixpls}} with the \code{\LinkA{sim}{sim}} function of the \code{simsem} package.
The standard errors and confidence intervals are estimated with the \code{\LinkA{boot}{boot}} and \code{\LinkA{boot.ci}{boot.ci}} functions
of the \code{boot} package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matrixpls.sim(
  nRep = NULL,
  model = NULL,
  n = NULL,
  ...,
  cilevel = 0.95,
  citype = c("norm", "basic", "stud", "perc", "bca"),
  boot.R = 500,
  fitIndices = fitSummary,
  outfundata = NULL,
  outfun = NULL,
  prefun = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nRep}] Number of replications. If any of the \code{n}, \code{pmMCAR}, or \code{pmMAR} arguments are specified as lists, the number of replications will default to the length of the list(s), and \code{nRep} need not be specified.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{n}] 
Sample size. Either a single value, or a list of values to vary sample size across replications. The \code{n} argument can also be specified as a random distribution object; if any resulting values are non-integers, the decimal will be rounded.


\item[\code{...}] All other arguments are passed through to \code{\LinkA{sim}{sim}},
\code{\LinkA{matrixpls.boot}{matrixpls.boot}}, or \code{\LinkA{matrixpls}{matrixpls}}.

\item[\code{cilevel}] Confidence level. This argument will be forwarded to the \code{\LinkA{boot.ci}{boot.ci}} when calculating the confidence intervals.

\item[\code{citype}] Type of confidence interval. This argument will be forwarded to the \code{\LinkA{boot.ci}{boot.ci}} when calculating the confidence intervals.

\item[\code{boot.R}] Number of bootstrap replications to use to estimate standard errors or \code{FALSE} to disable bootstrapping.

\item[\code{fitIndices}] A function that returns a list of fit indices for the model. Setting this argument to \code{NULL} disables fit indices.

\item[\code{outfundata}] A function to be applied to the \code{matrixpls} output and the 
generated data after each replication. Users can get the characteristics of the 
generated data and also compare the characteristics with the generated output. 
The output from this function in each replication will be saved in the 
simulation output (SimResult), and can be obtained using the getExtraOutput function.

\item[\code{outfun}] A function to be applied to the  \code{matrixpls} output at each replication. 
Output from this function in each replication will be saved in the simulation 
output (SimResult), and can be obtained using the getExtraOutput function.

\item[\code{prefun}] A function to be applied to the dataset before each replication. The output of this
function is passed as arguments to \code{\LinkA{matrixpls}{matrixpls}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function calls the \code{\LinkA{sim}{sim}} function from the \code{simsem} package to perform Monte
Carlo simulations with matrixpls. The function parses the model parameters and replaces it with
a function call that estimates the model and bootstrapped standard errors and confidence
intervals with \LinkA{matrixpls.boot}{matrixpls.boot}.

If the \code{generate} or \code{rawdata} arguments are not specified in the \code{\LinkA{sim}{sim}} arguments
then the \code{model} argument will be used for data generation and must be specified in lavaan format.
\end{Details}
%
\begin{Value}
An object of class \code{\LinkA{SimResult-class}{SimResult.Rdash.class}}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{matrixpls}{matrixpls}}, \code{\LinkA{matrixpls.boot}{matrixpls.boot}}, \code{\LinkA{sim}{sim}}, \code{\LinkA{SimResult-class}{SimResult.Rdash.class}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
if(!require(simsem)){
    print("This example requires the simsem package")
} else{

#
# Runs the second model from
#
# Aguirre-Urreta, M., & Marakas, G. (2013). Partial Least Squares and Models with Formatively 
# Specified Endogenous Constructs: A Cautionary Note. Information Systems Research. 
# doi:10.1287/isre.2013.0493

library(MASS)

X <- diag(15) 
X[upper.tri(X, diag=TRUE)] <- c(
  1.000,
  0.640, 1.000,
  0.640, 0.640, 1.000,
  0.640, 0.640, 0.640, 1.000,
  0.096, 0.096, 0.096, 0.096, 1.000,
  0.096, 0.096, 0.096, 0.096, 0.640, 1.000,
  0.096, 0.096, 0.096, 0.096, 0.640, 0.640, 1.000,
  0.096, 0.096, 0.096, 0.096, 0.640, 0.640, 0.640, 1.000,
  0.115, 0.115, 0.115, 0.115, 0.192, 0.192, 0.192, 0.192, 1.000,
  0.115, 0.115, 0.115, 0.115, 0.192, 0.192, 0.192, 0.192, 0.640, 1.000,
  0.115, 0.115, 0.115, 0.115, 0.192, 0.192, 0.192, 0.192, 0.640, 0.640,
  1.000,
  0.115, 0.115, 0.115, 0.115, 0.192, 0.192, 0.192, 0.192, 0.640, 0.640,
  0.640, 1.000,
  0.000, 0.000, 0.000, 0.000, 0.271, 0.271, 0.271, 0.271, 0.325, 0.325,
  0.325, 0.325, 1.000,
  0.000, 0.000, 0.000, 0.000, 0.271, 0.271, 0.271, 0.271, 0.325, 0.325,
  0.325, 0.325, 0.300, 1.000,
  0.000, 0.000, 0.000, 0.000, 0.271, 0.271, 0.271, 0.271, 0.325, 0.325,
  0.325, 0.325, 0.300, 0.300, 1.000
)
X <- X + t(X) - diag(diag(X)) 

colnames(X) <- rownames(X) <- c(paste("Y",1:12,sep=""),paste("X",1:3,sep=""))

# Print the population covariance matrix X to see that it is correct

X

# The estimated model in Lavaan syntax

analyzeModel <- "
ksi =~ Y1 + Y2 + Y3 + Y4
eta1 <~ X1 + X2 + X3
eta2 =~ Y5 + Y6 + Y7 + Y8
eta3 =~ Y9 + Y10 + Y11 + Y12

eta1 ~ ksi
eta2 ~ eta1
eta3 ~ eta1
"

# Only run 100 replications without bootstrap replications each so that the 
# example runs faster. Generate the data outside simsem because simsem
# does not support drawing samples from population matrix

dataSets <- lapply(1:100, function(x){
  mvrnorm(300,                 # Sample size
          rep(0,15),           # Means
          X)                   # Population covarancematrix
})

Output <- matrixpls.sim(model = analyzeModel, rawData = dataSets, boot.R=FALSE,
                        multicore = FALSE, stopOnError = TRUE)

summary(Output)


}
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{matrixplsboot}{Bootstrapping of matrixpls function}{matrixplsboot}
\aliasA{matrixpls.boot}{matrixplsboot}{matrixpls.boot}
\aliasA{summary.matrixplsboot}{matrixplsboot}{summary.matrixplsboot}
%
\begin{Description}\relax
\code{matrixpls.boot} is a convenience method that implements bootstrapping of \code{matrixpls}
with \code{\LinkA{boot}{boot}} method of the \code{boot} package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matrixpls.boot(
  data,
  model,
  ...,
  R = 500,
  signChange = NULL,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  dropInadmissible = FALSE,
  stopOnError = FALSE,
  extraFun = NULL
)

## S3 method for class 'matrixplsboot'
summary(object, ..., ci.type = "all")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Matrix or data frame containing the raw data.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{...}] All other arguments are passed through to \code{\LinkA{matrixpls}{matrixpls}} and \code{\LinkA{boot}{boot}}.

\item[\code{R}] Number of bootstrap samples to draw.

\item[\code{signChange}] Sign change correction function.

\item[\code{parallel}] 
The type of parallel operation to be used (if any).  If missing, the
default is taken from the option \code{"boot.parallel"} (and if that
is not set, \code{"no"}).


\item[\code{ncpus}] 
integer: number of processes to be used in parallel operation:
typically one would chose this to the number of available CPUs.


\item[\code{dropInadmissible}] A logical indicating whether non-convergent and inadmissible replications
should be discarded.

\item[\code{stopOnError}] A logical indicating whether boostrapping should be continued when error occurs
in a replication.

\item[\code{extraFun}] A function that takes a \code{matrixpls} object and a boostrap sample and returns a numeric vector. The
vector is appended to bootstrap replication. Can be used for boostrapping additional
statistics calculated based on the estimation results.

\item[\code{object}] object of class \code{matrixplsboot}

\item[\code{ci.type}] A vector of character strings representing the type of intervals required. Passed on to \code{\LinkA{boot.ci}{boot.ci}}. If \code{"none"}, 
no confidence intervals are calculated.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An object of class \code{matrixplsboot} and \code{\LinkA{boot}{boot}}.
\end{Value}
%
\begin{Section}{Analyzing the boostrap results}


The output can be analyzed with any of the functions provided by the \code{\LinkA{boot}{boot}} package.
For example, the \code{\LinkA{boot.ci}{boot.ci}} function can be used for calculating confidence 
intervals and the \code{\LinkA{empinf}{empinf}} function can be used to calculate influence values that may
be useful for identifying outliers.

The class \code{matrixplsboot} provides only a \code{summary} function, which calculates a set
of statistics that are commonly of interest after boostrapping. This includes standard errors,
t statistics (estimate / SE) and p-values based on Student's t distribution and standard normal
distribution. Because the sampling distribution of the parameter estimates calculated by 
\code{matrixpls} are not always known, the p-values cannot be expected to be unbiased.

This concern
applies particularly when using PLS weights. Because the PLS literature provides conflicting
advice on which probability distribution to use as a reference, the \code{summary} method of 
\code{matrixplsboot} produces two-tailed p-values based on four different probability
distributions. The \emph{regression} p values are based on comparing the t statistic against
the references distribution used in regression analysis, namely Student's t distribution with 
\code{n - k - 1} degrees of freedom. The \emph{Hair} p values are based on 
Hair et al's (2014, p. 134) recommendation to ignore the number of independent variables 
\code{k} and set the degrees of freedom to \code{n - 1}. The \emph{Henseler} p values are based
on the recommendation by
Henseler et al (2009, p. 305) that the degrees of freedom should be set as \code{n + m - 2},
where \code{m}is always 1 and \code{n} is the number of bootstrap samples. The \code{z} p values
are based on comparing the t statistic against the standard normal distribution. This choice
can be motivated by asymptotic normality of the PLS estimates in certain conditions.
\end{Section}
%
\begin{References}\relax
Hair, J. F., Hult, G. T. M., Ringle, C. M., \& Sarstedt, M. (2014). 
\emph{A primer on partial least squares structural equations modeling (PLS-SEM)}.
Los Angeles: SAGE.

Henseler, J., Ringle, C. M., \& Sinkovics, R. R. (2009). The use of partial
least squares path modeling in international marketing.
\emph{Advances in International Marketing}, 20, 277–319.

Rönkkö, M., \& Evermann, J. (2013). A critical examination of common beliefs
about partial least squares path modeling. 
\emph{Organizational Research Methods}, 16(3), 425–448. 
doi:\nobreakspace{}\Rhref{https://doi.org/10.1177/1094428112474693}{10.1177\slash{}1094428112474693}

Rönkkö, M., McIntosh, C. N., \& Antonakis, J. (2015). On the adoption of
partial least squares in psychological research: Caveat emptor.
\emph{Personality and Individual Differences}, (87), 76–84.
doi:\nobreakspace{}\Rhref{https://doi.org/10.1016/j.paid.2015.07.019}{10.1016\slash{}j.paid.2015.07.019}
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{boot}{boot}}

Sign change corrections: \code{\LinkA{signChange.individual}{signChange.individual}}; \code{\LinkA{signChange.construct}{signChange.construct}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Run the customer satisfaction example form plspm

# load dataset satisfaction
data(satisfaction)
# inner model matrix
IMAG = c(0,0,0,0,0,0)
EXPE = c(1,0,0,0,0,0)
QUAL = c(0,1,0,0,0,0)
VAL = c(0,1,1,0,0,0)
SAT = c(1,1,1,1,0,0)
LOY = c(1,0,0,0,1,0)
inner = rbind(IMAG, EXPE, QUAL, VAL, SAT, LOY)
colnames(inner) <- rownames(inner)

# Reflective model

reflective<- matrix(
  c(1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1),
  27,6, dimnames = list(colnames(satisfaction)[1:27],colnames(inner)))

# empty formative model

formative <- matrix(0, 6, 27, dimnames = list(colnames(inner),
                                              colnames(satisfaction)[1:27]))

# Only 100 replications to make the example faster when running on single processor. 
# Increase the number of replications (e.g. to 500) to get the BCa intervals

matrixpls.boot.out <- matrixpls.boot(satisfaction[,1:27],
                           model = list(inner = inner,
                                        reflective = reflective,
                                        formative = formative),
                           R = 100)

print(matrixpls.boot.out)
summary(matrixpls.boot.out)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{optimCrit}{Optimization criteria functions}{optimCrit}
\methaliasA{optimCrit.gsca}{optimCrit}{optimCrit.gsca}
\methaliasA{optimCrit.maximizeFullR2}{optimCrit}{optimCrit.maximizeFullR2}
\methaliasA{optimCrit.maximizeIndicatorR2}{optimCrit}{optimCrit.maximizeIndicatorR2}
\methaliasA{optimCrit.maximizeInnerR2}{optimCrit}{optimCrit.maximizeInnerR2}
%
\begin{Description}\relax
Optimization criterion functions calculate various optimization criterion values
from \code{matrixpls} objects.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
optimCrit.maximizeInnerR2(matrixpls.res)

optimCrit.maximizeIndicatorR2(matrixpls.res)

optimCrit.maximizeFullR2(matrixpls.res)

optimCrit.gsca(matrixpls.res)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{matrixpls.res}] An object of class \code{matrixpls} from which the
criterion function is calculated
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Value of the optimization criterion.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{optimCrit.maximizeInnerR2}: maximizes the sum of R2 statistics of the \code{inner} matrix

\item{} \code{optimCrit.maximizeIndicatorR2}: maximizes the sum of R2 statistics of the \code{reflective} matrix.

\item{} \code{optimCrit.maximizeFullR2}: maximizes the sum of R2 statistics of the \code{inner} and \code{reflective} matrices.

\item{} \code{optimCrit.gsca}: minimizes the generalized structured component analysis criterion. See \LinkA{GSCA}{GSCA}

\end{itemize}
\end{Section}
%
\begin{SeeAlso}\relax
\code{\LinkA{weightFun.optim}{weightFun.optim}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{outerEstim}{PLS outer estimation}{outerEstim}
\methaliasA{outerEstim.fixed}{outerEstim}{outerEstim.fixed}
\methaliasA{outerEstim.gsca}{outerEstim}{outerEstim.gsca}
\methaliasA{outerEstim.modeA}{outerEstim}{outerEstim.modeA}
\methaliasA{outerEstim.modeB}{outerEstim}{outerEstim.modeB}
%
\begin{Description}\relax
Calculates a set of unstandardized outer weights.

Mode A outer weights are correlations between indicators and composites.
Mode B outer weights are regression coefficients of composites on indicators. 

For information about GSCA weights, see \LinkA{GSCA}{GSCA}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
outerEstim.modeA(S, W, E, W.model, ...)

outerEstim.modeB(S, W, E, W.model, ...)

outerEstim.gsca(S, W, E, W.model, model, ...)

outerEstim.fixed(S, W, E, W.model, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{W}] Weight matrix, where the indicators are on colums and composites are on the rows.

\item[\code{E}] Inner weight matrix. A square matrix of inner estimates between the composites.

\item[\code{W.model}] A matrix specifying the weight relationships and their starting values.

\item[\code{...}] All other arguments are ignored.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of unscaled outer weights \code{W} with the same dimensions as \code{W.model}.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{outerEstim.modeA}: Mode A outer estimation.

\item{} \code{outerEstim.modeB}: Mode B outerestimation.

\item{} \code{outerEstim.gsca}: outer estimation with generalized structured component analysis.

\item{} \code{outerEstim.fixed}: Fixed weights. Returns the starting weights specified in \code{W.model}

\end{itemize}
\end{Section}
%
\begin{References}\relax
Lohmöller J.-B. (1989) \emph{Latent variable path modeling with partial least squares.} Heidelberg: Physica-Verlag.
\end{References}
\inputencoding{utf8}
\HeaderA{parameterEstim}{Parameter estimation of full model}{parameterEstim}
\methaliasA{parameterEstim.separate}{parameterEstim}{parameterEstim.separate}
%
\begin{Description}\relax
\code{paramsEstimator} functions estimates the statistical model described by \code{model}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
parameterEstim.separate(
  S,
  model,
  W,
  ...,
  parametersInner = estimator.ols,
  parametersReflective = estimator.ols,
  parametersFormative = estimator.ols,
  disattenuate = FALSE,
  reliabilities = reliabilityEstim.weightLoadingProduct
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{W}] Weight matrix, where the indicators are on colums and composites are on the rows.

\item[\code{...}] All other arguments are passed through to \code{parametersInner},
\code{parametersReflective}, and\code{parametersFormative}

\item[\code{parametersInner}] A function used to estimate the \code{inner} model matrix. The default is
\code{\LinkA{estimator.ols}{estimator.ols}}

\item[\code{parametersReflective}] A function used to estimate the \code{reflective} model matrix. The
default is \code{\LinkA{estimator.ols}{estimator.ols}}

\item[\code{parametersFormative}] A function used to estimate the \code{formative} model matrix. The
default is \code{\LinkA{estimator.ols}{estimator.ols}}

\item[\code{disattenuate}] If \code{TRUE}, \code{C} is
disattenuated before applying \code{parametersInner}.

\item[\code{reliabilities}] A function for calculating reliability estimates based on the 
data covariance matrix \code{S}, factor loading matrix \code{loadings}, and a weight matrix \code{W}.
Returns a vector of reliability estimates. The default is
\code{\LinkA{reliabilityEstim.weightLoadingProduct}{reliabilityEstim.weightLoadingProduct}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Model can be specified in the lavaan format or the native matrixpls format.
The native model format is a list of three binary matrices, \code{inner}, \code{reflective},
and \code{formative} specifying the free parameters of a model: \code{inner} (\code{l x l}) specifies the 
regressions between composites, \code{reflective} (\code{k x l}) specifies the regressions of observed
data on composites, and \code{formative} (\code{l x k}) specifies the regressions of composites on the
observed data. Here \code{k} is the number of observed variables and \code{l} is the number of composites.

If the model is specified in lavaan format, the native
format model is derived from this model by assigning all regressions between latent
variables to \code{inner}, all factor loadings to \code{reflective}, and all regressions
of latent variables on observed variables to \code{formative}. Regressions between
observed variables and all free covariances are ignored. All parameters that are
specified in the model will be treated as free parameters.

The original papers about Partial Least Squares, as well as many of the current PLS
implementations, impose restrictions on the matrices \code{inner},
\code{reflective}, and \code{formative}: \code{inner} must be a lower triangular matrix,
\code{reflective} must have exactly one non-zero value on each row and must have at least
one non-zero value on each column, and \code{formative} must only contain zeros.
Some PLS implementations allow \code{formative} to contain non-zero values, but impose a
restriction that the sum of \code{reflective} and \code{t(formative)} must satisfy
the original restrictions of \code{reflective}. The only restrictions that matrixpls
imposes on \code{inner}, \code{reflective}, and \code{formative} is that these must be
binary matrices and that the diagonal of \code{inner} must be zeros.

Model estimation proceeds as follows. The weights \code{W} and the
data covariance matrix \code{S} are used to calculate the composite covariance matrix \code{C}
and the indicator-composite covariance matrix \code{IC}. These are matrices are used to
separately estimate each of the three model matrices \code{inner}, \code{reflective}, and
\code{formative}. This approach of estimating the parameter matrices separately is the
standard way of estimation in the PLS literature.

The default estimation approach is to estimate all parameters with a series of OLS 
regressions using \code{\LinkA{estimator.ols}{estimator.ols}}.
\end{Details}
%
\begin{Value}
A named vector of parameter estimates.

\code{parameterEstim.separate} returns the following as attributes:

\begin{ldescription}
\item[\code{C}] the composite correlation matrix (after disattenuation, if requested).
\item[\code{IC}] the indicator-composite covariance matrix (after disattenuation, if requested).
\item[\code{inner}] the \code{inner} model matrix with estimated parameters.
\item[\code{reflective}] the \code{reflective} model matrix with estimated parameters.
\item[\code{formative}] the \code{formative} model matrix with estimated parameters.
\item[\code{Q}] the reliability estimates used in disattenuation.

\end{ldescription}
Additionally, all attributes returned by functions called by parameterEstim.separate are returned.
This can include:
\begin{ldescription}
\item[\code{c}] the PLSc loading estimate correction factors.
\end{ldescription}
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{parameterEstim.separate}: Estimates the model parameters in \code{inner}, \code{reflective}, and
\code{formative} separately.

\end{itemize}
\end{Section}
%
\begin{References}\relax
Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling. \emph{Journal of Statistical Software}, 48(2), 1–36. Retrieved from http://www.jstatsoft.org/v48/i02
\end{References}
\inputencoding{utf8}
\HeaderA{predict.matrixpls}{Predict method for matrixpls results}{predict.matrixpls}
\keyword{post-estimation functions}{predict.matrixpls}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{predict} predict.
Predicts the reflective indicators of endogenous latent variables using
estimated model and data for the indicators of exogenous latent variables
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'matrixpls'
predict(
  object,
  newData,
  predictionType = c("exogenous", "redundancy", "communality", "composites"),
  means = NULL,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{newData}] A data frame or a matrix containing data used for prediction.

\item[\code{predictionType}] "exogenous" (default) predicts indicators from exogenous 
composites. "redundancy" and "communality" are alternative strategies 
described by Chin (2010). "composites" returns the composites calculated 
by multiplying the data with the weight matrix.

\item[\code{means}] A vector of means of the original data used to calculate 
intercepts for the linear prediction equations. If not provided, calculated
from the new data or assumed zero.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix of predicted values for reflective indicators of endogenous
latent variables or weighted composites of the indicators.
\end{Value}
%
\begin{References}\relax
Wold, H. (1974). Causal flows with latent variables: Partings of the ways in 
the light of NIPALS modeling. \emph{European Economic Review}, 5(1), 67–86. 
doi:\nobreakspace{}\Rhref{https://doi.org/10.1016/0014-2921(74)90008-7}{10.1016\slash{}0014\-2921(74)90008\-7}

Chin, W. W. (2010). How to write up and report PLS analyses. In V. Esposito Vinzi, W. W. Chin, J.
Henseler, \& H. Wang (Eds.), Handbook of partial least squares (pp. 655–690). Berlin Heidelberg: Springer.
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{r2}{r2}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Run the customer satisfaction example form plspm

# load dataset satisfaction
data(satisfaction)
# inner model matrix
IMAG = c(0,0,0,0,0,0)
EXPE = c(1,0,0,0,0,0)
QUAL = c(0,1,0,0,0,0)
VAL = c(0,1,1,0,0,0)
SAT = c(1,1,1,1,0,0)
LOY = c(1,0,0,0,1,0)
inner = rbind(IMAG, EXPE, QUAL, VAL, SAT, LOY)
colnames(inner) <- rownames(inner)

# Reflective model

reflective<- matrix(
  c(1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1),
  27,6, dimnames = list(colnames(satisfaction)[1:27],colnames(inner)))

# empty formative model

formative <- matrix(0, 6, 27, dimnames = list(colnames(inner),
                                              colnames(satisfaction)[1:27]))

satisfaction.model <- list(inner = inner,
                           reflective = reflective,
                           formative = formative)

# Estimation using covariance matrix


satisfaction.out <- matrixpls(cov(satisfaction[,1:27]),
                           model = satisfaction.model)

print(satisfaction.out)



# Predict indicators using means from the data
predict(satisfaction.out, 
        newData = satisfaction,
        means= sapply(satisfaction, mean))

# Calculate composite scores
predict(satisfaction.out, 
        newData = satisfaction,
        predictionType = "composites")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{q2}{Q2	predictive relevance statistics}{q2}
%
\begin{Description}\relax
Calculates Q2 predictive relevance statistics based on comparing predictions
and real data.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
q2(originalData, predictedData, model = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{originalData}] A matrix or a data.frame containing the original data.

\item[\code{predictedData}] A matrix or a data.frame containing the predicted data that are compared
against the original data to calculate the predictive relevance statistic.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The Q2 statistic is calculated as \code{1-sse/sso} where \code{sse} is the sum of 
squared prediction errors based on comparison of the \code{originalData} and 
\code{predictedData} and \code{sso} is based on prediction with mean. If the predicted
data contain the \code{groups} attribute, which indicates the groups used in blindfolding
or cross-validation, the means are calculated separately for each group excluding the 
predicted group from the calculation.
\end{Details}
%
\begin{Value}
A list with \code{total}, \code{block}, and \code{indicator} elements containing
the Q2 predictive relevance statistics for the full dataset, for each indicator block, and
for each indicator
\end{Value}
\inputencoding{utf8}
\HeaderA{r2}{R2	for matrixpls results}{r2}
\keyword{post-estimation functions}{r2}
%
\begin{Description}\relax
The \code{matrixpls} method for the generic function \code{r2} computes the squared multiple correlation (R2)
for composites predicted by other composites in the model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
r2(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A named numeric vector containing the R2 values.
\end{Value}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{residuals.matrixpls}{residuals.matrixpls}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{reliabilityEstim}{Reliabilities as products of weights and loadings}{reliabilityEstim}
\methaliasA{reliabilityEstim.alpha}{reliabilityEstim}{reliabilityEstim.alpha}
\methaliasA{reliabilityEstim.weightLoadingProduct}{reliabilityEstim}{reliabilityEstim.weightLoadingProduct}
%
\begin{Description}\relax
Calculates reliabilities as a matrix product of loadings and weights.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
reliabilityEstim.weightLoadingProduct(S, loadings, W, ...)

reliabilityEstim.alpha(S, loadings, W, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] the data covariance matrix

\item[\code{loadings}] matrix of factor loading estimates

\item[\code{W}] matrix of weights

\item[\code{...}] All other arguments are ignored.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a named vector of estimated composite reliabilities.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{reliabilityEstim.weightLoadingProduct}: Reliability estimation based on weights and loadings.

\item{} \code{reliabilityEstim.alpha}: Reliability estimation with Cronbach's alpha

\end{itemize}
\end{Section}
\inputencoding{utf8}
\HeaderA{residuals.matrixpls}{Residual diagnostics for matrixpls results}{residuals.matrixpls}
\keyword{post-estimation functions}{residuals.matrixpls}
%
\begin{Description}\relax
The \code{matrixpls} method for generic function \code{residuals} computes the residual
covariance matrix and various fit indices.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'matrixpls'
residuals(object, ..., observed = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] matrixpls estimation result object produced by the \code{\LinkA{matrixpls}{matrixpls}} function.

\item[\code{...}] All other arguments are ignored.

\item[\code{observed}] If \code{TRUE} (default) the observed residuals from the outerEstim.model regressions
(indicators regressed on composites) are returned. If \code{FALSE}, the residuals are calculated
by combining  \code{inner}, \code{reflective}, and \code{formative} as a simultaneous equations
system and subtracting the covariances implied by this system from the observed covariances.
The error terms are constrained to be uncorrelated and covariances between exogenous observed
values are fixed at their sample values.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The residuals can be
either observed residuals from the regressions of indicators on composites and composites 
on composites
(i.e. the \code{reflective} and \code{inner} models) as presented by Lohmöller (1989, ch 2.4) or 
model implied residuals calculated by subtracting model implied covariance matrix from the 
sample covariance matrix as done by Henseler et al. (2014). 

The root mean squared residual indices (Lohmöller, 1989, eq 2.118) are calculated from the
off diagonal elements of the residual covariance matrix. The
standardized root mean squared residual (SRMR) is calculated based on the standardized residuals
of the \code{reflective} model matrix. 

Following Hu and Bentler (1999, Table 1), the SRMR index is calculated by dividing with 
\eqn{p(p+1)/2}{}, where \eqn{p}{} is the number of indicator variables. In typical SEM applications,
the diagonal of residual covariance matrix consists of all zeros because error term variances
are freely estimated. To make the SRMR more comparable with the index produced by 
SEM software, the SRMR is calculated by summing only the squares of off-diagonal elements,
which is equivalent to including a diagonal of all zeros. 

Two versions of the 
SRMR index are rovided, the traditional SRMR that includes all residual covariances, and the 
version proposed by Henseler et al. (2014) where the within-block residual covariances are 
ignored.
\end{Details}
%
\begin{Value}
A list with three elements: \code{inner}, \code{outer}, and \code{indices} elements
containing the residual covariance matrix of regressions of composites on other composites,
the residual covariance matrix of indicators on composites, and various indices
calculated based on the residuals.
\end{Value}
%
\begin{References}\relax
Henseler, J., Dijkstra, T. K., Sarstedt, M., Ringle, C. M., Diamantopoulos, A., Straub, D. W., …
Calantone, R. J. (2014). Common Beliefs and Reality About PLS Comments on Rönkkö and Evermann 
(2013). \emph{Organizational Research Methods}, 17(2), 182–209. doi:\nobreakspace{}\Rhref{https://doi.org/10.1177/1094428114526928}{10.1177\slash{}1094428114526928}

Hu, L., \& Bentler, P. M. (1999). Cutoff criteria for fit indexes in covariance structure 
analysis: Conventional criteria versus new alternatives. \emph{Structural Equation Modeling: 
A Multidisciplinary Journal}, 6(1), 1–55.

Lohmöller J.-B. (1989) \emph{Latent variable path modeling with partial
least squares.} Heidelberg: Physica-Verlag.
\end{References}
%
\begin{SeeAlso}\relax
Other post-estimation functions: 
\code{\LinkA{ave}{ave}()},
\code{\LinkA{cei}{cei}()},
\code{\LinkA{cr}{cr}()},
\code{\LinkA{effects.matrixpls}{effects.matrixpls}()},
\code{\LinkA{fitSummary}{fitSummary}()},
\code{\LinkA{fitted.matrixpls}{fitted.matrixpls}()},
\code{\LinkA{gof}{gof}()},
\code{\LinkA{htmt}{htmt}()},
\code{\LinkA{loadings}{loadings}()},
\code{\LinkA{predict.matrixpls}{predict.matrixpls}()},
\code{\LinkA{r2}{r2}()}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{signChange}{Sign change corrections for bootstrap}{signChange}
\methaliasA{signChange.construct}{signChange}{signChange.construct}
\methaliasA{signChange.individual}{signChange}{signChange.individual}
%
\begin{Description}\relax
These functions selectively reverse the signs of the weights in boostrap samples to be consistent 
with the weights calculated based on the original sample.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
signChange.individual(Worig, W)

signChange.construct(Worig, W)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Worig}] The original weight matrix.

\item[\code{W}] a Weight matrix of a bootstrap sample.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Sign change corrections are a controversial and inconsistently implemented feature in PLS analysis.
The two corrections described in the literature are the individual sign chance correction and the
construct level sign chance corrections.
The individual correction changes the signs of \code{W} to match \code{Worig}.

The construct level correction changes the signs of \code{W} on all rows where the sign of the
sum of the row differs between \code{Worig} and \code{W}.

The sign chance corrections are described ambiguosly and sometimes implemented inconsistently
between software. \pkg{matrixpls} implements the corrections by adjusting the weights before
calculating parameter estimates in each bootstrap replication. Some software implement the
correction post-hoc by adjusting the bootstrap estimates directly. Moreover, the 
literature present at least two different formulas for the construct level correction. 
\pkg{matrixpls} implements the version described by Tenenhaus et al. (2005).

The sign chance
corrections should not be confused with sign indeterminacy corrections applied to 
individual analyses
(See \code{\LinkA{weightSign}{weightSign}}).
\end{Details}
%
\begin{Value}
A weight matrix with the same dimensions as \code{W} after applying the correction.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{signChange.individual}: individual sign change correction

\item{} \code{signChange.construct}: individual sign change correction

\end{itemize}
\end{Section}
%
\begin{References}\relax
Tenenhaus, M., Esposito Vinzi, V., Chatelin, Y.-M., \& Lauro, C. (2005). PLS Path Modeling.
\emph{Computational Statistics \& Data Analysis}, 48(1), 159–205. 
doi:\nobreakspace{}\Rhref{https://doi.org/10.1016/j.csda.2004.03.005}{10.1016\slash{}j.csda.2004.03.005}

Rönkkö, M., McIntosh, C. N., \& Antonakis, J. (2015). On the adoption of 
partial least squares in psychological research: Caveat emptor. 
\emph{Personality and Individual Differences}, (87), 76–84.
doi:\nobreakspace{}\Rhref{https://doi.org/10.1016/j.paid.2015.07.019}{10.1016\slash{}j.paid.2015.07.019}
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{matrixpls.boot}{matrixpls.boot}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{weightFun}{Indicator weight algoritms}{weightFun}
\methaliasA{weightFun.factor}{weightFun}{weightFun.factor}
\methaliasA{weightFun.fixed}{weightFun}{weightFun.fixed}
\methaliasA{weightFun.optim}{weightFun}{weightFun.optim}
\methaliasA{weightFun.pls}{weightFun}{weightFun.pls}
\methaliasA{weightFun.principal}{weightFun}{weightFun.principal}
\keyword{Weight algorithms}{weightFun}
%
\begin{Description}\relax
Estimates a weight matrix using Partial Least Squares or a related algorithm.

\code{weightFun.factor} calculates weights by estimating a common factor analysis model with a single factor for each 
indicator block and using the resulting estimates to calculate factor score weights

\code{weightFun.principal} calculates weights by calculating a principal component analysis for each 
indicator block and returning the weights for the first principal component.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
weightFun.pls(
  S,
  model,
  W.model,
  outerEstim = NULL,
  innerEstim = innerEstim.path,
  ...,
  convCheck = convCheck.absolute,
  variant = "lohmoller",
  tol = 1e-05,
  iter = 100,
  validateInput = TRUE
)

weightFun.optim(
  S,
  model,
  W.model,
  parameterEstim = parameterEstim.separate,
  optimCrit = optimCrit.maximizeInnerR2,
  method = "BFGS",
  ...,
  validateInput = TRUE,
  standardize = TRUE
)

weightFun.fixed(S, model, W.model = NULL, ..., standardize = TRUE)

weightFun.factor(
  S,
  model,
  W.model = NULL,
  ...,
  fm = "minres",
  standardize = TRUE
)

weightFun.principal(S, model, W.model = NULL, ..., standardize = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{S}] Covariance matrix of the data.

\item[\code{model}] There are two options for this argument: 1. lavaan script or lavaan parameter
table, or 2. a list containing three matrices
\code{inner}, \code{reflective}, and \code{formative} defining the free regression paths
in the model.

\item[\code{W.model}] A matrix specifying the weight relationships and their starting values.

\item[\code{outerEstim}] A function or a list of functions used for outer estimation. If
the value of this parameter is a function, the same function is applied to all
composites. If the value is a list, the composite \code{n} is estimated
with the estimator in the \code{n}th position in the list. If this argument is
\code{NULL} the \code{\LinkA{outerEstim.modeA}{outerEstim.modeA}} is used for all composites that are linked to at least
one indicator in the \code{reflective} matrix.\code{\LinkA{outerEstim.modeB}{outerEstim.modeB}} is used for all other
composites. See \code{\LinkA{outerEstim}{outerEstim}}.

\item[\code{innerEstim}] A function for calculating inner weights using  the data covariance matrix
\code{S}, a weight matrix \code{W}, and an inner model matrix \code{inner.mod}. Returns
an inner weight matrix \code{E}. The default is \code{\LinkA{innerEstim.path}{innerEstim.path}}.

\item[\code{...}] All other arguments are passed through to other estimation functions.

\item[\code{convCheck}] A function that takes the old \code{Wold} and new weight \code{Wold} matrices and
returns a scalar that is compared against \code{tol} to check for convergence. The default
is \code{\LinkA{convCheck.absolute}{convCheck.absolute}}.

\item[\code{variant}] Choose either Lohmöller's (\code{"lohmoller"}, default) or Wold's (\code{"wold"}) 
variant of PLS. In Wold's variant the inner and outer estimation steps are repeated for each
indicator block whereas in Lohmöller's variant the weights for all composites are calculated
simultaneously.

\item[\code{tol}] Decimal value indicating the tolerance criterion for convergence.

\item[\code{iter}] An integer indicating the maximum number of iterations.

\item[\code{validateInput}] A boolean indicating whether the validity of the parameter values should be tested.

\item[\code{parameterEstim}] A function for estimating the model parameters using
the data covariance matrix \code{S}, model specification \code{model}, 
and weight matrix \code{W}. Returns a named vector of parameter estimates.
The default is \code{\LinkA{parameterEstim.separate}{parameterEstim.separate}}

\item[\code{optimCrit}] A function for calculating value for an optimization criterion based on a
\code{matrixpls} result object. Returns a scalar. The default is \code{\LinkA{optimCrit.maximizeInnerR2}{optimCrit.maximizeInnerR2}}.

\item[\code{method}] The minimization algorithm to be used. See \code{\LinkA{optim}{optim}}
for details. Default is \code{"BFGS"}.

\item[\code{standardize}] A boolean indicating whether \code{S} the weights should be scaled to produce
standardized composites.

\item[\code{fm}] factoring method for estimating the common factor model. Possible values are
\code{minres}, \code{wls}, \code{gls}, \code{pa}, and \code{ml}. The parameter is passed through to
to \code{\LinkA{fa}{fa}}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Model can be specified in the lavaan format or the native matrixpls format.
The native model format is a list of three binary matrices, \code{inner}, \code{reflective},
and \code{formative} specifying the free parameters of a model: \code{inner} (\code{l x l}) specifies the 
regressions between composites, \code{reflective} (\code{k x l}) specifies the regressions of observed
data on composites, and \code{formative} (\code{l x k}) specifies the regressions of composites on the
observed data. Here \code{k} is the number of observed variables and \code{l} is the number of composites.

If the model is specified in lavaan format, the native
format model is derived from this model by assigning all regressions between latent
variables to \code{inner}, all factor loadings to \code{reflective}, and all regressions
of latent variables on observed variables to \code{formative}. Regressions between
observed variables and all free covariances are ignored. All parameters that are
specified in the model will be treated as free parameters.

The original papers about Partial Least Squares, as well as many of the current PLS
implementations, impose restrictions on the matrices \code{inner},
\code{reflective}, and \code{formative}: \code{inner} must be a lower triangular matrix,
\code{reflective} must have exactly one non-zero value on each row and must have at least
one non-zero value on each column, and \code{formative} must only contain zeros.
Some PLS implementations allow \code{formative} to contain non-zero values, but impose a
restriction that the sum of \code{reflective} and \code{t(formative)} must satisfy
the original restrictions of \code{reflective}. The only restrictions that matrixpls
imposes on \code{inner}, \code{reflective}, and \code{formative} is that these must be
binary matrices and that the diagonal of \code{inner} must be zeros.

The argument \code{W.model} is a (\code{l x k}) matrix that indicates
how the indicators are combined to form the composites. The original papers about
Partial Least Squares as well as all current PLS implementations define this as
\code{t(reflective) | formative}, which means that the weight patter must match the
model specified in \code{reflective} and \code{formative}. Matrixpls does not
require that \code{W.model} needs to match \code{reflective} and \code{formative}, but
accepts any numeric matrix. If this argument is not specified, all elements of \code{W.model} that
correspond to non-zero elements in the \code{reflective} or \code{formative} formative
matrices receive the value 1.

\code{weightFun.pls} calculates indicator weights by calling the 
\code{innerEstim} and \code{outerEstim} iteratively until either the convergence criterion or
maximum number of iterations is reached and provides the results in a matrix.

\code{weightFun.optim} calculates indicator weights by optimizing the indicator
weights against the criterion function using \code{\LinkA{optim}{optim}}. The
algorithm works by first estimating the model with the starting weights. The
resulting \code{matrixpls} object is passed to the \code{optimCrit}
function, which evaluates the optimization criterion for the weights. The
weights are adjusted and new estimates are calculated until the optimization
criterion converges.
\end{Details}
%
\begin{Value}
An object of class \code{"matrixplsweights"}, which is a matrix containing the weights with the following attributes:

\begin{ldescription}
\item[\code{iterations}] Number of iterations performed

\item[\code{converged}] A boolean indicating if the algorithm converged

\item[\code{history}] A data.frame containing the weights for each iteration

\end{ldescription}
\code{weightFun.pls} returns the following as attributes:

\begin{ldescription}
\item[\code{S}] the sample covariance matrix.
\item[\code{E}] inner weight matrix.
\item[\code{iterations}] the number of iterations used by the weight algorithm.
\item[\code{converged}] \code{TRUE} if the weight algorithm converged and \code{FALSE} otherwise.
\item[\code{history}] weight optimization history as a matrix.
\end{ldescription}
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{weightFun.pls}: partial Least Squares and other iterative two-stage weight algorithms.

\item{} \code{weightFun.optim}: calculates a set of weights to minimize an optimization criterion.

\item{} \code{weightFun.fixed}: returns the starting weights.

\item{} \code{weightFun.factor}: blockwise factor score weights.

\item{} \code{weightFun.principal}: blockwise principal component weights.

\end{itemize}
\end{Section}
%
\begin{References}\relax
Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling. \emph{Journal of Statistical Software}, 48(2), 1–36. Retrieved from http://www.jstatsoft.org/v48/i02
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
# Run the customer satisfaction examle form plspm

# load dataset satisfaction
data(satisfaction)
# inner model matrix
IMAG = c(0,0,0,0,0,0)
EXPE = c(1,0,0,0,0,0)
QUAL = c(0,1,0,0,0,0)
VAL = c(0,1,1,0,0,0)
SAT = c(1,1,1,1,0,0)
LOY = c(1,0,0,0,1,0)
inner = rbind(IMAG, EXPE, QUAL, VAL, SAT, LOY)
colnames(inner) <- rownames(inner)

# Reflective model
list(1:5, 6:10, 11:15, 16:19, 20:23, 24:27)

reflective<- matrix(
  c(1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1),
  27,6, dimnames = list(colnames(satisfaction)[1:27],colnames(inner)))

# empty formative model

formative <- matrix(0, 6, 27, dimnames = list(colnames(inner), colnames(satisfaction)[1:27]))

# Estimation using covariance matrix
model <- list(inner = inner,
              reflective = reflective,
              formative = formative)

S <- cov(satisfaction[,1:27])

matrixpls.ModeA <- matrixpls(S, model)
matrixpls.ModeB <- matrixpls(S, model, outerEstim = outerEstim.modeB)
matrixpls.MaxR2 <- matrixpls(S, model, weightFun = weightFun.optim)

# Compare the R2s from the different estimations

R2s <- cbind(r2(matrixpls.ModeA), r2(matrixpls.ModeB), r2(matrixpls.MaxR2))
print(R2s)
apply(R2s,2,mean)

# Optimization against custom function

maximizeSumOfCorrelations <- function(matrixpls.res){
  C <- attr(matrixpls.res,"C")
  model <- attr(matrixpls.res,"model")
  - sum(C[model$inner != 0])
}

matrixpls.MaxCor <- matrixpls(S, model, weightFun = weightFun.optim,
                             optimCrit = maximizeSumOfCorrelations)

# Compare the Mode B and optimized solutions

C <- attr(matrixpls.ModeB,"C")
print(C)
print(sum(C[inner != 0]))
C <- attr(matrixpls.MaxCor,"C")
print(C)
print(sum(C[inner != 0]))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{weightSign}{Sign ambiguity corrections}{weightSign}
\methaliasA{weightSign.dominantIndicator}{weightSign}{weightSign.dominantIndicator}
\methaliasA{weightSign.Wold1985}{weightSign}{weightSign.Wold1985}
%
\begin{Description}\relax
Sign ambiguity corrections adjust the signs of the weights to satisfy a criterion.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
weightSign.Wold1985(W, S)

weightSign.dominantIndicator(W, S)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{W}] Weight matrix, where the indicators are on colums and composites are on the rows.

\item[\code{S}] Covariance matrix of the data.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Instead of fixing a weight to a particular value, composite variables are typically provided a
scale by standardization. This leads to sign indeterminacy because standardized weights \code{W}
and \code{-W} both satisfy the scaling constraint. The sing ambiguity corrections add additional
constraints that make 

The sign indeterminacy
corrections should not be confused with sign chance corrections applied to boostrap samples 
(See \code{\LinkA{signChange}{signChange}}).
\end{Details}
%
\begin{Value}
\code{W} after sign correction.
\end{Value}
%
\begin{Section}{Functions}
\begin{itemize}

\item{} \code{weightSign.Wold1985}: Adjust the signs of W so that the majority of the indicators are positively 
correlated with the composite as proposed by Wold (1985).

\item{} \code{weightSign.dominantIndicator}: Adjust the signs of W so that the first indicator of each composite has positive
weight.

\end{itemize}
\end{Section}
%
\begin{References}\relax
Wold, H. (1985). Partial Least Squares. In S. Kotz \& N. L. Johnson (Eds.), Encyclopedia  of 
statistical sciences (Vol. 6, pp. 581–591). New York: Wiley.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{matrixpls}{matrixpls}};
\end{SeeAlso}
\printindex{}
\end{document}
